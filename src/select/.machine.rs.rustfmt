use std::time::Instant;

use {Receiver, Sender};
use err::{TryRecvError, TrySendError};
use select::handle;
use select::CaseId;
use util;

#[derive(Debug)]
pub struct Machine {
    len: usize,
    first_id: CaseId,
    deadline: Option<Instant>,
    pub disconnected_cases: u8,
    pub would_block_cases: u8,
    pub timed_out_cases: u8,
    start: usize, // TODO: rename to start_index

    pub state: State,
    index: usize,
}

impl Machine {
    #[inline]
    pub fn new() -> Self {
        Self::with_deadline(None)
    }

    #[inline]
    pub fn with_deadline(deadline: Option<Instant>) -> Self {
        Machine {
            len: 0,
            first_id: CaseId::none(),
            deadline,
            disconnected_cases: 0,
            would_block_cases: 0,
            timed_out_cases: 0,
            start: 0,

            state: State::Count,
            index: 0,
        }
    }

    #[inline(always)]
    pub fn step(&mut self, case_id: CaseId) -> Option<&mut State> {
        loop {
            if self.state == State::Count {
                // TODO: Fail at the right moment, not here!
                assert!(self.disconnected_cases <= 1, "there are multiple `disconnected` cases");
                assert!(self.would_block_cases <= 1, "there are multiple `would_block` cases");
                assert!(self.timed_out_cases <= 1, "there are multiple `timed_out` cases");

                if self.first_id == case_id {
                    // TODO: what if len == 0?
                    self.state = State::Try {
                        disconnected_count: 0,
                    };
                    self.index = 0;
                    self.start = util::small_random(self.len); // TODO: rename util to utils (because e.g. std::collections)
                } else {
                    if self.len == 0 {
                        self.first_id = case_id;
                    }
                    self.len += 1;
                    self.index += 1;
                }
                return None;
            } else {
                if self.index >= 2 * self.len {
                    self.state.transition(self.len, self.deadline);
                    self.index = 0;
                } else {
                    let index = self.index;
                    self.index += 1;

                    if self.start <= index && index < self.start + self.len {
                        return Some(&mut self.state);
                    } else {
                        return None;
                    }
                }
            }
        }
    }
}

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum State {
    Count,
    Try { disconnected_count: usize },
    Promise { disconnected_count: usize },
    Revoke { case_id: CaseId },
    Fulfill { case_id: CaseId },
    Disconnected,
    WouldBlock,
    TimedOut,
}

impl State {
    #[inline(always)]
    pub fn transition(&mut self, len: usize, deadline: Option<Instant>) {
        match *self {
            State::Try { disconnected_count } => {
                if disconnected_count == len {
                    *self = State::Disconnected;
                } else if !allow_blocking {
                    *self = State::WouldBlock;
                } else {
                    handle::current_reset();
                    *self = State::Promise { disconnected_count: 0 };
                }
            },
            State::Promise { disconnected_count } => {
                if disconnected_count < len {
                    handle::current_wait_until(deadline);
                } else {
                    handle::current_try_select(CaseId::abort());
                }
                *self = State::Revoke {
                    case_id: handle::current_selected(),
                };
            }
            State::Revoke { case_id } => {
                *self = State::Fulfill { case_id };
            }
            State::Fulfill { .. } => {
                *self = State::Try { disconnected_count: 0 };

                if let Some(end) = deadline {
                    if Instant::now() >= end {
                        *self = State::TimedOut;
                    }
                }
            }
            State::Disconnected => {}
            State::WouldBlock => {}
            State::TimedOut => {}
            State::Count => {}
        }
    }

    #[inline(always)]
    pub fn send<T>(&mut self, tx: &Sender<T>, mut msg: T) -> Result<(), T> {
        match *self {
            State::Try {
                ref mut disconnected_count,
            } => {
                match tx.try_send(msg) {
                    Ok(()) => return Ok(()),
                    Err(TrySendError::Full(m)) => msg = m,
                    Err(TrySendError::Disconnected(m)) => {
                        msg = m;
                        *disconnected_count += 1;
                    }
                }
            },
            State::Promise {
                ref mut disconnected_count,
            } => {
                tx.promise_send();

                if tx.is_disconnected() {
                    *disconnected_count += 1;
                } else if tx.can_send() {
                    handle::current_try_select(CaseId::abort());
                }
            }
            State::Revoke { case_id } => {
                if tx.case_id() != case_id {
                    tx.revoke_send();
                }
            },
            State::Fulfill { case_id } => {
                if tx.case_id() == case_id {
                    match tx.fulfill_send(msg) {
                        Ok(()) => return Ok(()),
                        Err(m) => msg = m,
                    }
                }
            },
            State::Disconnected => {}
            State::WouldBlock => {}
            State::TimedOut => {}
            State::Count => {}
        }
        Err(msg)
    }

    #[inline(always)]
    pub fn recv<T>(&mut self, rx: &Receiver<T>) -> Result<T, ()> {
        match *self {
            State::Try {
                ref mut disconnected_count,
            } => {
                match rx.try_recv() {
                    Ok(m) => return Ok(m),
                    Err(TryRecvError::Empty) => {}
                    Err(TryRecvError::Disconnected) => *disconnected_count += 1,
                }
            },
            State::Promise {
                ref mut disconnected_count,
            } => {
                rx.promise_recv();

                let is_disconn = rx.is_disconnected();
                let can_recv = rx.can_recv();

                if is_disconn && !can_recv {
                    *disconnected_count += 1;
                } else if can_recv {
                    handle::current_try_select(CaseId::abort());
                }
            }
            State::Revoke { case_id } => {
                if rx.case_id() != case_id {
                    rx.revoke_recv();
                }
            },
            State::Fulfill { case_id } => {
                if rx.case_id() == case_id {
                    if let Ok(m) = rx.fulfill_recv() {
                        return Ok(m);
                    }
                }
            },
            State::Disconnected => {}
            State::WouldBlock => {}
            State::TimedOut => {}
            State::Count => {}
        }
        Err(())
    }
}
